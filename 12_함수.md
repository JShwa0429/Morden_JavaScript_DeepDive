# 12. 함수

- 수학적으로, 입력을 받아 출력을 내보내는 일련의 과정
- 프로그래밍 언어의 함수는 일련의 과정을 문으로 구현하고, 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것을 의미한다.

## 12-01.

```js
// add(x,y) = x + y
function add(x, y) {
  return x + y;
}

// f(2,5) = 7
add(2, 5); // 7
```

#

### 함수의 구성요소

- 함수 내부로 입력을 전달받는 매개변수
- 입력을 인수, 출력을 반환값이라 한다.

```js
//함수 정의
//function 을 제외한 함수 정의 부분을 함수 몸체라 칭함
function 함수이름(매개변수) {
  return 반환값;
}

//함수 호출
함수이름(인수);
```

#

## 12-02.

- 함수는 함수 정의를 통해 생성한다.

```js
//함수 선언문을 통한 함수 정의
function add(x, y) {
  return x + y;
}
```

#

### 함수 호출

- 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시하는 것
- 함수를 호출하면 코드 블록에 담긴 문들이 일괄적으로 실행되고 실행결과, 즉 반환값을 반환한다.

## 12-03

```js
//함수 호출
var result = add(2, 5);

//함수 add에 인수 2, 5를 전달하면서 호출하면 반환값 7을 반환한다.
console.log(result); // 7
```

#

## 함수를 사용해야하는 이유

- 코드의 중복을 억제하고 재사용성을 높이는 함수는 <B>유지보수의 편의성</B>을 높이고, 실수를 줄여 <B>코드의 신뢰성</B>을 높이는 효과가 있다.
- 적절한 함수 이름은 함수의 내부 코드를 이해하지 않고도 함수의 역할을 파악할 수 있게 돕는다. 이는 <b>코드의 가독성</b>을 향상시킨다.

#

## 함수 리터럴

```js
var f = function add(x, y) {
  return x + y;
};
```

- 리터럴은 값을 생성하기 위한 표기법이다.
- 함수 리터럴도 평가되어 값을 생성하며, 이 값은 객체다.
- 즉, <b>함수는 객체다.</b>
- 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.
- 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.

#

## 함수 정의

```js
function add() {} // 함수 선언문
var a = function () {}; // 익명함수 리터럴
var b = function c() {}; // 기명함수 리터럴

console.dir(a); // name: 'a'
console.dir(b); // name : 'c'
// 익명과 기명의 차이는  name property가 다르다는 점에 있다.
```

- 함수 선언문은 함수 리터럴과 형태가 동일하다.
- 단, <b>함수 선언문은 리터럴과 달리 함수 이름을 생략할 수 없다.</b>
- 함수 선언문은 <b>표현식이 아닌 문이다.</b>

#

## 함수 선언문이 변수처럼 할당되어보이는 이유

```js
// 함수 선언문은 표현식이 아닌 문이므로 변수로 할당할 수 없다.
// 하지만 함수 선언문이 변수에 할당되는 것처럼 보인다.
var add = function add(x, y) {
  return x + y;
};

//함수 호출
console.log(add(2, 5));
```

- 자바스크립트 엔진이 코드의 문맥에 따라 다른 식으로 해석하기 때문.
- 동일한 함수 리터럴을 표현식이 아닌, 문인 함수 선언문으로 해석하는 경우
- 표현식인 문이 함수 리터럴 표현식으로 해석하는 경우, 두 가지 상황이 존재.

```
예를 들어 {}은 블록문 일 수도 있고 객체 리터럴일 수도 있다.
```

- {}처럼 중의적인 코드는 코드의 문맥에 따라 해석이 달라진다.
- {} 이 단독으로 존재할 경우 자바스크립트 엔진은 {}을 블록문으로 해석한다.
- 하지만 {}이 값으로 평가되어야할 문맥(ex.할당 연산자의 우변)에서 피연산자로 사용되면 자바스크립트 엔진은 {}을 객체 리터럴로 해석한다.

  `이처럼 동일한 코드도 코드의 문맥에 따라 해석이 달라질 수 있다.`

```js
// 기명 함수 리터럴을 단독으로 사용 시 함수 선언문으로 해석된다.
// 함수 선언문에서는 함수 이름을 생략할 수 없다.
function foo() {
  console.log("foo");
}

foo();

//함수 리터럴을 피연산자로 사용하면 함수 선언문이 아닌 함수 리터럴 표현식으로 해석된다.
// 함수 리터럴에서는 함수 이름을 생략할 수 있다.
// 그룹 연산자 () 내에 있는 함수 리터럴(bar)은 함수 선언문으로 해석되지 않고, 함수 리터럴 표현식으로 해석된다.
(function bar() {
  console.log("bar");
});
bar(); // ReferencceError : bar is not defined.
```

`자바스크립트 엔진은 생성된 함수를 호출하기 위해 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 거기에 함수 객체를 할당한다.`

## 함수 표현식

- 값의 성질을 갖는 객체를 일급 객체라고 하며, 자바스크립트의 함수는 일급 객체이다.
- 일급객체 : https://ko.wikipedia.org/wiki/일급_객체 참조
- 함수를 호출할 때는 함수 이름이 아닌함수 객체를 가르키는 식별자를 사용해야 한다. 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로, 함수 이름으로 함수를 호출할 수 없다.

```js
//기명 함수 표현식
var add = function foo(x, y) {
  return x + y;
};

console.log(add(2, 5)); // 7

// 함수 이름으로 호출하면 ReferenceError 발생
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자다.

console.log(foo(2, 5)); // ReferenceError : foo is not defined.
```

`함수 선언문은 "표현식이 아닌 문"이고, 함수 표현식은 "표현식인 문"이다.`

## 함수 생성 시점과 함수 호이스팅

```js
//함수 참조
console.dir(add); // f add(x,y)
console.dir(sub); // undefined

//함수 호출
console.log(add(2, 5)); // 7
console.log(sub(2, 5)); // TypeError : sub is not a function

//함수 선언문
function add(x, y) {
  return x + y;
}

//함수 표현식
var sub = function (x, y) {
  return x - y;
};
```

- 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다.
- 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.
- `함수 선언문과 함수 표현식의 함수 생성 시점이 다르기 때문.`

```
함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는
자바스크립트 고유의 특징을 함수 호이스팅이라고 한다.
```

- 함수 호이스팅과 변수 호이싕은 미묘한 차이가 있으므로 주의해야한다.
- var 키워드로 선언된 변수는 undefined로 초기화되고,
- 함수 선언문을 통해 암묵적으로 생성된 식별자는 <B>함수 객체</B>로 초기화된다.
- `변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.`
- 즉, 함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생한다.

## Function 생성자 함수

- Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성해서 반환한다.
- 사실 new 연산자 없이 호출해도 결과는 동일하다.

```
생성자 함수란?
객체를 생성하는 함수를 의미한다.
```

```js
var add = new Function("x", "y", "return x+y");
console.log(add(2, 5)); // 7
```

- Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않고 바람직하지도 않다.
- 이렇게 만들어진 함수는 클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다.

```js
var add1 = (function () {
  var a = 10;
  return function (x, y) {
    return x + y + a;
  };
})();

console.log(add1(1, 2)); // 13

var add2 = function () {
  var a = 10;
  return new Function("x", "y", "return x+y+a;");
};

console.log(add2(1, 2)); // Reference : a is not defined.
```

#

## 화살표 함수

- ES6에서 도입된 화살표 함수는 function 키워드 대신 화살표를 사용해 좀 더 간ㄹ냑한 방법으로 함수를 선언할 수 있다. 화살표 함수는 항상 익명 함수로 정의한다.

```js
const add = (x, y) => x + y;
console.log(add(2, 5));
```

- 화살표 함수는 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르다.
- prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.

#

## 함수 호출

- 함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출
- 함수 호출 연산자 내에는 0개 이상의 인수를 쉼표로 구분해서 나열한다.
- 함수를 호출하면 현재의 실행 흐릉을 중단하고 호출된 함수로 실행 흐름을 옮긴다.
- 이 때 매개변수에 인수가 순서대로 할당되고 함수 몸체의 문들이 실행된다.

\

```js
function add(x, y) {
  return x + y;
}

// 함수 호출
// 인수 1과 인수 2가 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.
var result = add(1, 2);
```

- 함수는 매개변수의 개수와 인수의 개수가 일치하는 지 체크하지 않는다.
- 인수가 부족해서 인수가 할당되지 않은 매개변수의 값은 undefined이다.

```js
function add(x, y) {
  return x + y;
}

console.log(add(2)); // 2 + undefined => NaN
```

- 매개변수보다 인수가 많은 경우 초과된 인수는 무시된다.
- 사실 초과된 인수는 그냥 버려지는 것이 아니다.
- 모든 인수는 암묵적으로 arguments 객체의 프로퍼티에 보관된다.

  ```js
  function add(x, y) {
    console.log(arguments);
    //Arguments(3) [2,5,10, callee : f, Symbol(Symbol.iterator):f]
    return x + y;
  }
  add(2, 5, 10);
  ```

- arguments 객체는 함수를 정의할 때 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용할 수 있다.

## 인수 확인

```js
function add(x, y) {
  return x + y;
}

console.log(add(2)); //NaN
console.log(add("a", "b")); // 'ab'
```

- 위 코드는 문법 상 어떠한 문제도 없다.

1. 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
2. 자바스크립트는 동적 타입 언어다. 따라서 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.

- 따라서 타입스크립트(https://www.typescriptlang.org)와 같은 정적 타입을 선언할 수 있는 자바스크립트 상위 확장을 도입해서 컴파일 시점에 부적절한 호출을 방지할 수 있게 하는 것도 하나의 방법이다.
- 인수가 전달되지 않은 경우 단축평가를 통해 매개변수에 기본값을 할당하는 방법도 있다.

```js
function add(a, b, c) {
  a = a || 0;
  b = b || 0;
  c = c || 0;
  return a + b + c;
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add(1)); // 1
console.log(add()); // 0
```

- ES6에서 도입된 매개변수 기본값을 사용하면 함수 내에서 수행하던 인수 체크 미 초기화를 간소화할 수 있다.
- 매개변수 기본값은 매개변수에 인수를 전달하지 않았을 경우와 인수 자체가 undefined 일 때 유효하다.

```js
function add(a = 0, b = 0, c = 0) {
  return a + b + c;
}

console.log(add(1, 2, 3)); // 6
console.log(add(1, 2)); // 3
console.log(add(1)); // 1
console.log(add()); // 0
```

#

## 매개변수의 최대 개수

ECMAScript 사양에서는 매개변수의 최대 개수에 대해 명시적으로 제한하고 있지 않다.

- 하지만 매개변수는 순서에 의미가 있다.
- 따라서 매개변수가 많아지면 함수를 호출할 때 전달해야할 인수의 순서를 고려해야한다.
- 이는 함수의 사용법을 이해하기 어렵게 만들고, 실수를 발생시킨다.
- 매개변수의 개수나 순서가 변경되면 함숙를 사용하는 코드 전체가 영향을 받으므로 그만큼 유지보수성이 나빠진다.
- `함수의 매개변수는 코드를 이해하는 데 방해되는 요소이므로, 이상적인 매개변수 개수는 0개이며 적을수록 좋다.`
- 이상적인 함수는 한 가지 일만 해야 하며 가급적 작게 만들어야 한다.
- 따라서 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다.
- 그 이상의 매개변수가 필요하면 객체를 인수로 전달하는 것이 유리하다.

#

## 반환문

- 함수는 return 키워드와 표현식으로 이루어진 반환문을 사용해 실행 결과를 함수 외부로 반환(return)할 수 있다.
- 반환문은 두 가지 역할을 한다.
  - 첫째, 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다.
    - 따라서 반환문 이후에 다른 문이 존재한다면 그 문은 실행도히지 않고 무시된다.
  - 둘째, 반환문은 return 키워드 뒤에 오는 표현식을 평가해 반환한다.
    - return 키워드 뒤에 반환값으로 사용할 표현식을 명시적으로 지정하지 않으면 undefined가 반환된다.
- 반환문은 생략할 수 있다. 이 때 함수는 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환한다.

```js
function multiply(x, y) {
  // return 키워드와 반환값 사이에 줄바꿈이 있다면
  return; // 세미콜론 자동 삽입 기능(ASI)에 의해 세미콜론이 추가된다.
  x * y; // 무시된다.
}

console.log(multiply(3, 5)); //undefined;
```

- 전역에서 반환문을 사용하면 문법 에러(Syntax Error : Illegal return statement)가 발생한다.
- 참고로 Node.js는 모듈 시스템에 의해 파일별로 독립적인 파일 스코프를 갖는다. 따라서 Node.js 환경에서는 가장 바깥 영역에 반환문을 사용해도 에러가 발생하지 않는다.

#

## 참조에 의한 전달과 외부 상태의 변경

```js
// 매개변수 primitive는 원시 값을 전달받고, 매개변수 obj는 객체를 전달받는다.
function ChangeVal(primitive, obj) {
  primitive += 100;
  obj.name = "Kim";
}

//외주 상태
var num = 100;
var person = { name: "Lee" };

console.log(num); // 100
console.log(person); // {name : "Lee"}

// 원시 값은 값 자체가 복사되어 전달되고, 객체는 참조 값이 복사되어 전달된다.
changeVal(num, person);

//원시값은 원본이 훼손되지 않는다.
console.log(num); // 100

// 객체는 원본이 훼손된다`
console.log(person); // {name: 'Kim'}
```

- 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다.
- 이는 코드의 복잡성을 증가시키고 가독성을 해치는 원인이 된다.
- 이러한 현상은 객체가 변경할 수 있는 값임며, 참조에 의한 전달 방식으로 동작하기 때문에 발생하는 부작용이다.
- 객체의 변경을 추적하려면 옵저버 패턴(https://ko.wikipedia.org/wiki/옵서버_패턴) 등을 통해 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요하다.
- `이러한 문제의 해결 방법중 하나는 객체를 불변 객체로 만들어 사용하는 것이다. `
  - 객체의 복사본을 새롭게 생성하는 비용은 들지만, 객체를 마치 원시값처럼 변경 불가능한 값으로 동작하게 만드는 것이다.
  - 이를 통해 객체의 상태 변경을 원천봉쇄하고 객체의 상태 변경이 필요한 경우에는 객체의 방어적 복사를 통해 원본 객체를 완전히 복제, 즉 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다.

```
외부 상태를 변경하지 않고 외부 상태에 의존하지도 않는 함수를 순수 함수라 한다.
```

순수함수를 통해 부수 효과를 최대한 억제하여 오류를 피하고 프로그래밍의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라고 한다.

#

## 다양한 함수의 형태

### 즉시 실행 함수

- 함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수라 한다.
- 즉시 실행 함수는 단 한 번만 호출되며 다시는 호출할 수 없다.

```js
(function () {
  var a = 3;
  var b = 5;
  return a * b;
})();

(function foo() {
  var a = 3;
  var b = 5;
  return a * b;
})();

foo(); // ReferenceError : foo is not defined;
```

- 기명 함수로 해도 되나 다시 호출할 수 없어서 의미가 없다.
- 즉시 실행 함수는 반드시 그룹 연산자 (...)로 감싸야만 한다.
- 함수 선언문 뒤에 (...)는 함수 호출 연산자가 아닌 그룹 연산자로 해석되고, 그룹 연산자에 피연산자가 없기 때문에 오류가 발생한다.

```js
(function () {
  // ...
})();

(function () {
  //...
})();

!(function () {
  // ...
})();

+(function () {
  // ...
})();
```

- 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다.

```js
var res = (function () {
  var a = 3;
  var b = 5;
  return a * b;
})();

console.log(res); // 15

res = (function (a, b) {
  return a * b;
})(3, 5);

console.log(res); // 15
```

## 재귀 함수

- 함수가 자기 자신을 호출하는 것을 재귀 호출이라고 한다.
- 재귀 함수는 재귀 호출을 수행하는 함수를 의미한다.

```js
function countdown(n) {
  for (var i = n; i >= 0; i--) console.log(i);
}

countdown(10);

function countdown2(n) {
  if (n < 0) return;
  console.log(n);
  countdown2(n - 1); // 재귀 호출
}

countdown2(10); // 둘이 같은 결과를 보여준다.
```

- 이처럼 재귀 함수를 사용하면 반복되는 처리를 반복문 없이 구현할 수 있다.
- 재귀 함수 내에는 반드시 재귀 호출을 멈출 수 있는 탈출 조건을 만들어야 한다.
- 재귀 함수는 반복문을 사용하는 것보다 재귀 함수를 사용하는 편이 더 직관적으로 이해하기 쉬울 때만 한정적으로 사용하는 것이 바람직하다.

## 중첩 함수

- 함수 내부에 정의된 함수를 내부 함수 또는 중첩 함수라고 한다.
- 그리고 중첩 함수를 포함하고 있는 함수를 외부 함수라고 한다.

## 콜백 함수

```js
function repeat(n, f) {
  for (var i = 0; i < n; i++) {
    f(i);
  }
}

var logAll = function (i) {
  console.log(i);
};

repeat(5, logAll); // 0 1 2 3 4

var logOdds = function (i) {
  if (i % 2) console.log(i);
};

repeat(5, logOdds); // 1 3
```

- 함수의 변하지 않는 공통 로직은 미리 정의해 두고, 경우에 따라 변경되는 로직은 추상화해서 함수 외부에서 함수 내부로 전달하는 것
- 이처럼 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백 함수라고 한다.
- 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차 함수라고 한다.
- 고차함숮는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정해서 호출한다.
- 즉, 콜백 함수는 고차 함수에 의해 호출되며 이 때 고차 함수는 필요에 따라 콜백 함수에 인수를 전달할 수 있다.

```js
// 익명 함수 리터럴읅 콜백 함수로 고차 함수에 전달한다.
// 익명 함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성한다.
repeat(5, (i) => {
  if (i % 2) console.log(i);
});
```

- 이 때 콜백 함수로써 전달된 함수 리터럴ㅇ느 고차 함수가 호출될 때마다 평가되어 함수 객체를 생성한다.
- 따라서 콜백 함수를 전달받는 함수가 자주 호출되는 경우에는 함수 외부에서 콜백 함수를 정의한 후 고차함수에 전달하는 것이 <b>효율적</b>이다.

```js
var logOdds = function (i) {
  if (i % 2) console.log(i);
};

repeat(5, logOdds);
```

- 콜백 함수는 함수형 프로그래밍 패러다임 뿐만 아니라 비동기 처리(이벤트 처리, Ajax 처리, 타이머 함수 등)에 활용되는 중요한 패턴이다.

```js
// 콜백 함수를 사용한 이벤트 처리
// myButton을 클릭하면 콜백 함수를 실행한다.
document.getElementById("myButton").addEventListener("click", function () {
  console.log("button clicked");
});

//콜백함수를 이용한 비동기 처리
// 1초 후에 메시지를 출력한다.
setTimeout(function () {
  console.log("1초 경과");
}, 1000);
```

- 콜백 함수는 비동기 처리 뿐만 아니라 배열 고차 함수에서도 사용된다.

```js
var res = [1, 2, 3].map(function (item) {
  return item * 2;
});

console.log(res); // [2,4,6]

res = [1, 2, 3].filter(function (item) {
  return item % 2;
});

console.log(res); // [1,3]

res = [1, 2, 3].reduce(function (acc, cur) {
  return acc + cur;
}, 0);

console.log(res); // 6
```

#

## 순수 함수와 비순수 함수

- 함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 변경하지도 않는, 즉 부수 효과가 없는 함수를 <b>순수 함수</b>라 한다.
- 반대로 외부 상태에 의존하거나 외부 상태를 변경하는, 부수 효과가 있는 함수를 <b>비순수 함수</b>라고 한다.

### 순수 함수

- 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.
  - 즉, 순수 함수는 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해 값을 생성해 반환한다.
  - 함수 외부 상태에 의존하는 함수는 외부 상태에 따라 반환값이 달라진다.
  - 외부 상태에는 전역 변수, 서버 데이터, 파일, Console, DOM 등이 있다.
  - 만약 함수 내부 상태에만 의존한다고 해도, 그 내부 상태가 호출될 때마다 변화하는 값(예를 들어 현재 시간)이라면 순수 함수가 아니다.
- 순수 함수는 최소 하나 이상의 인수를 받는다.
- 인수를 전달받지 않는 순수 함수는 언제나 동일한 값을 반환하므로 상수와 마찬가지이다.
- 또한 순수 함수는 인수를 변경하지 않는 것이 기본이다.
  - 순수 함수는 인수의 불변성을 유지한다.

```js
var count = 0; // 현재 카운트를 나타내는 상태

function increase(n) {
  return ++n;
}

count = increase(count);
console.log(count); // 1

count = increase(count);
console.log(count); // 2
```

### 비순수 함수

- 반대로 외부 상태에 따라 반환값이 달라지는 함수를 비순수 함수라고 한다.
- 비순수 함수는 함수의 외부 상태를 변경하는 부수 효과가 있다.
- 즉, 비순수 함수는 외부 상태에 의존하거나 외부 상태를 변경하는 함수이다.

```js
var count = 0;

function increase() {
  return ++count;
}

increase();
console.log(count); // 1

increase();
console.log(count); // 2
```

- `함수가 외부 상태를 변경하면 상태 변화를 추적하기 어렵다.`
- 따라서 함수 외부 상태의 변경을 지양하는 순수 함수를 지양하는 것이 좋다.
- 비순수 함수를 최대한 줄이는 것은 부수 효과를 최대한 억제하는 것과 같다.

### 함수형 프로그래밍

- 함수형 프로그래밍이란 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임이다.
- 로직 내에 존재하는 조건문과 반복문을 제거해서 복잡성을 해결한다.
- 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화하는 것을 목표로 한다.
- 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 해서 가독성을 해치고, 변수의 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적인 원인이 될 수 있기 때문이다.
